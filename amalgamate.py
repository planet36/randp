#!/usr/bin/env python3
# SPDX-FileCopyrightText: 2025 ChatGPT (OpenAI o4-mini-high)
# SPDX-FileCopyrightText: Steven Ward
# SPDX-License-Identifier: OSL-3.0

import re
import sys
from pathlib import Path

# Usage: amalgamate.py <root-source-file> [search-paths...]
# If no search-paths are given, defaults to the root file's directory
# then the current working directory.
# e.g. python3 amalgamate.py libfoo.c .

# Note: using re.match anchors at the start of the string,
#       so an explicit '^' anchor is not required.
# Regex to match C include directives of the form #include "header.h".
# \s*         : zero or more leading whitespace
# #\s*        : '#' then zero or more spaces
# include     : literal 'include'
# \s*         : zero or more spaces
# "([^"]+)"   : capture file name inside double quotes
INCLUDE_FILE_PATTERN = re.compile(r'\s*#\s*include\s*"([^"]+)"')

paths_seen = set()
include_order = []


def find_file(name, search_paths):
    """
    Locate a file with the specified name within given search paths.

    Args:
        name (str): The filename to locate.
        search_paths (List[Path]): Directories to search for the file.

    Returns:
        Path: The Path object of the found file.

    Raises:
        FileNotFoundError: If the file is not found in any of the search paths.
    """
    for d in search_paths:
        candidate = d / name
        if candidate.is_file():
            return candidate
    raise FileNotFoundError(f'{name} not found in {search_paths}')


def dfs(path, search_paths):
    """
    Recursively traverse and record include dependencies in topological order.

    This function visits the given file, finds all included headers, and
    appends files to the global 'include_order' list after processing
    dependencies.

    Args:
        path (Path): The source or header file to process.
        search_paths (List[Path]): Directories to search for included headers.
    """
    if path in paths_seen:
        return
    paths_seen.add(path)
    with path.open('r', encoding='utf-8') as f:
        for line in f:
            m = INCLUDE_FILE_PATTERN.match(line)
            if m:
                included = find_file(m.group(1), search_paths)
                dfs(included, search_paths)
    include_order.append(path)


def emit(path):
    """
    Emit the contents of a file to standard output,
    excluding #include directives.

    Args:
        path (Path): The source or header file whose contents are emitted.
    """
    with path.open('r', encoding='utf-8') as f:
        for line in f:
            if INCLUDE_FILE_PATTERN.match(line):
                continue
            sys.stdout.write(line)


def main():
    script_name = Path(__file__).name

    if len(sys.argv) < 2:
        print(f'Usage: {script_name} <root.c> [search-path...]')
        sys.exit(1)

    root = Path(sys.argv[1])
    search_paths = [Path(p)
                    for p in (sys.argv[2:] or [root.parent, Path('.')])]

    # 1) build the include-order
    dfs(root, search_paths)

    fold_marker_begin = '{{{'
    fold_marker_end = '}}}'

    # 2) emit a single header
    print(f'// generated by {script_name}')
    print('// vim: set foldmethod=marker foldlevel=0:')
    for path in include_order:
        print()
        print(f'// {fold_marker_begin} {path.name}')
        emit(path)
        print(f'// {fold_marker_end}')


if __name__ == '__main__':
    main()
